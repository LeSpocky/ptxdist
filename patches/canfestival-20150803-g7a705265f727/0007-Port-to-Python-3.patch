From: Roland Hieber <rhi@pengutronix.de>
Date: Sun, 11 Feb 2024 22:28:38 +0100
Subject: [PATCH] Port to Python 3

Not all of the code was ported, only enough to make objdictgen calls in
the Makefile work enough to generate the code in examples/.
---
 objdictgen/commondialogs.py      |  2 +-
 objdictgen/eds_utils.py          | 76 ++++++++++++++++++++--------------------
 objdictgen/gen_cfile.py          | 25 +++++++------
 objdictgen/networkedit.py        |  4 +--
 objdictgen/node.py               | 57 +++++++++++++++---------------
 objdictgen/nodeeditortemplate.py | 10 +++---
 objdictgen/nodelist.py           |  2 +-
 objdictgen/nodemanager.py        | 25 +++++++------
 objdictgen/objdictedit.py        | 22 ++++++------
 objdictgen/objdictgen.py         | 20 +++++------
 10 files changed, 122 insertions(+), 121 deletions(-)

diff --git a/objdictgen/commondialogs.py b/objdictgen/commondialogs.py
index 77d6705bd70b..38b840b617c0 100644
--- a/objdictgen/commondialogs.py
+++ b/objdictgen/commondialogs.py
@@ -1566,7 +1566,7 @@ class DCFEntryValuesDialog(wx.Dialog):
         if values != "":
             data = values[4:]
             current = 0
-            for i in xrange(BE_to_LE(values[:4])):
+            for i in range(BE_to_LE(values[:4])):
                 value = {}
                 value["Index"] = BE_to_LE(data[current:current+2])
                 value["Subindex"] = BE_to_LE(data[current+2:current+3])
diff --git a/objdictgen/eds_utils.py b/objdictgen/eds_utils.py
index 969bae91dce5..aad8491681ac 100644
--- a/objdictgen/eds_utils.py
+++ b/objdictgen/eds_utils.py
@@ -53,8 +53,8 @@ BOOL_TRANSLATE = {True : "1", False : "0"}
 ACCESS_TRANSLATE = {"RO" : "ro", "WO" : "wo", "RW" : "rw", "RWR" : "rw", "RWW" : "rw", "CONST" : "ro"}
 
 # Function for verifying data values
-is_integer = lambda x: type(x) in (IntType, LongType)
-is_string = lambda x: type(x) in (StringType, UnicodeType)
+is_integer = lambda x: type(x) == int
+is_string = lambda x: type(x) == str
 is_boolean = lambda x: x in (0, 1)
 
 # Define checking of value for each attribute
@@ -174,7 +174,7 @@ def ParseCPJFile(filepath):
                             try:
                                 computed_value = int(value, 16)
                             except:
-                                raise SyntaxError, _("\"%s\" is not a valid value for attribute \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("\"%s\" is not a valid value for attribute \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                         elif value.isdigit() or value.startswith("-") and value[1:].isdigit():
                             # Second case, value is a number and starts with "0" or "-0", then it's an octal value
                             if value.startswith("0") or value.startswith("-0"):
@@ -193,59 +193,59 @@ def ParseCPJFile(filepath):
                         
                         if keyname.upper() == "NETNAME":
                             if not is_string(computed_value):
-                                raise SyntaxError, _("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                             topology["Name"] = computed_value
                         elif keyname.upper() == "NODES":
                             if not is_integer(computed_value):
-                                raise SyntaxError, _("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                             topology["Number"] = computed_value
                         elif keyname.upper() == "EDSBASENAME":
                             if not is_string(computed_value):
-                                raise SyntaxError, _("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                             topology["Path"] = computed_value
                         elif nodepresent_result:
                             if not is_boolean(computed_value):
-                                raise SyntaxError, _("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                             nodeid = int(nodepresent_result.groups()[0])
                             if nodeid not in topology["Nodes"].keys():
                                 topology["Nodes"][nodeid] = {}
                             topology["Nodes"][nodeid]["Present"] = computed_value
                         elif nodename_result:
                             if not is_string(value):
-                                raise SyntaxError, _("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                             nodeid = int(nodename_result.groups()[0])
                             if nodeid not in topology["Nodes"].keys():
                                 topology["Nodes"][nodeid] = {}
                             topology["Nodes"][nodeid]["Name"] = computed_value
                         elif nodedcfname_result:
                             if not is_string(computed_value):
-                                raise SyntaxError, _("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                             nodeid = int(nodedcfname_result.groups()[0])
                             if nodeid not in topology["Nodes"].keys():
                                 topology["Nodes"][nodeid] = {}
                             topology["Nodes"][nodeid]["DCFName"] = computed_value
                         else:
-                            raise SyntaxError, _("Keyname \"%s\" not recognised for section \"[%s]\"")%(keyname, section_name)
+                            raise SyntaxError(_("Keyname \"%s\" not recognised for section \"[%s]\"")%(keyname, section_name))
                         
                 # All lines that are not empty and are neither a comment neither not a valid assignment
                 elif assignment.strip() != "":
-                    raise SyntaxError, _("\"%s\" is not a valid CPJ line")%assignment.strip()
+                    raise SyntaxError(_("\"%s\" is not a valid CPJ line")%assignment.strip())
         
             if "Number" not in topology.keys():
-                raise SyntaxError, _("\"Nodes\" keyname in \"[%s]\" section is missing")%section_name
+                raise SyntaxError(_("\"Nodes\" keyname in \"[%s]\" section is missing")%section_name)
         
             if topology["Number"] != len(topology["Nodes"]):
-                raise SyntaxError, _("\"Nodes\" value not corresponding to number of nodes defined")
+                raise SyntaxError(_("\"Nodes\" value not corresponding to number of nodes defined"))
             
             for nodeid, node in topology["Nodes"].items():
                 if "Present" not in node.keys():
-                    raise SyntaxError, _("\"Node%dPresent\" keyname in \"[%s]\" section is missing")%(nodeid, section_name)
+                    raise SyntaxError(_("\"Node%dPresent\" keyname in \"[%s]\" section is missing")%(nodeid, section_name))
             
             networks.append(topology)
             
         # In other case, there is a syntax problem into CPJ file
         else:
-            raise SyntaxError, _("Section \"[%s]\" is unrecognized")%section_name
+            raise SyntaxError(_("Section \"[%s]\" is unrecognized")%section_name)
     
     return networks
 
@@ -275,7 +275,7 @@ def ParseEDSFile(filepath):
             if section_name.upper() not in eds_dict:
                 eds_dict[section_name.upper()] = values
             else:
-                raise SyntaxError, _("\"[%s]\" section is defined two times")%section_name
+                raise SyntaxError(_("\"[%s]\" section is defined two times")%section_name)
         # Second case, section name is an index name 
         elif index_result:
             # Extract index number
@@ -288,7 +288,7 @@ def ParseEDSFile(filepath):
                 values["subindexes"] = eds_dict[index]["subindexes"]
                 eds_dict[index] = values
             else:
-                raise SyntaxError, _("\"[%s]\" section is defined two times")%section_name
+                raise SyntaxError(_("\"[%s]\" section is defined two times")%section_name)
             is_entry = True
         # Third case, section name is a subindex name 
         elif subindex_result:
@@ -301,14 +301,14 @@ def ParseEDSFile(filepath):
             if subindex not in eds_dict[index]["subindexes"]:
                 eds_dict[index]["subindexes"][subindex] = values
             else:
-                raise SyntaxError, _("\"[%s]\" section is defined two times")%section_name
+                raise SyntaxError(_("\"[%s]\" section is defined two times")%section_name)
             is_entry = True
         # Third case, section name is a subindex name 
         elif index_objectlinks_result:
             pass
         # In any other case, there is a syntax problem into EDS file
         else:
-            raise SyntaxError, _("Section \"[%s]\" is unrecognized")%section_name
+            raise SyntaxError(_("Section \"[%s]\" is unrecognized")%section_name)
         
         for assignment in assignments:
             # Escape any comment
@@ -330,13 +330,13 @@ def ParseEDSFile(filepath):
                             test = int(value.upper().replace("$NODEID+", ""), 16)
                             computed_value = "\"%s\""%value
                         except:
-                            raise SyntaxError, _("\"%s\" is not a valid formula for attribute \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                            raise SyntaxError(_("\"%s\" is not a valid formula for attribute \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                     # Second case, value starts with "0x", then it's an hexadecimal value
                     elif value.startswith("0x") or value.startswith("-0x"):
                         try:
                             computed_value = int(value, 16)
                         except:
-                            raise SyntaxError, _("\"%s\" is not a valid value for attribute \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                            raise SyntaxError(_("\"%s\" is not a valid value for attribute \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                     elif value.isdigit() or value.startswith("-") and value[1:].isdigit():
                         # Third case, value is a number and starts with "0", then it's an octal value
                         if value.startswith("0") or value.startswith("-0"):
@@ -354,17 +354,17 @@ def ParseEDSFile(filepath):
                         if is_entry:
                             # Verify that keyname is a possible attribute
                             if keyname.upper() not in ENTRY_ATTRIBUTES:
-                                raise SyntaxError, _("Keyname \"%s\" not recognised for section \"[%s]\"")%(keyname, section_name)
+                                raise SyntaxError(_("Keyname \"%s\" not recognised for section \"[%s]\"")%(keyname, section_name))
                             # Verify that value is valid
                             elif not ENTRY_ATTRIBUTES[keyname.upper()](computed_value):
-                                raise SyntaxError, _("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name)
+                                raise SyntaxError(_("Invalid value \"%s\" for keyname \"%s\" of section \"[%s]\"")%(value, keyname, section_name))
                             else:
                                 values[keyname.upper()] = computed_value
                         else:
                             values[keyname.upper()] = computed_value
             # All lines that are not empty and are neither a comment neither not a valid assignment
             elif assignment.strip() != "":
-                raise SyntaxError, _("\"%s\" is not a valid EDS line")%assignment.strip()
+                raise SyntaxError(_("\"%s\" is not a valid EDS line")%assignment.strip())
         
         # If entry is an index or a subindex
         if is_entry:
@@ -384,7 +384,7 @@ def ParseEDSFile(filepath):
                     attributes = _("Attributes %s are")%_(", ").join(["\"%s\""%attribute for attribute in missing])
                 else:
                     attributes = _("Attribute \"%s\" is")%missing.pop()
-                raise SyntaxError, _("Error on section \"[%s]\":\n%s required for a %s entry")%(section_name, attributes, ENTRY_TYPES[values["OBJECTTYPE"]]["name"])
+                raise SyntaxError(_("Error on section \"[%s]\":\n%s required for a %s entry")%(section_name, attributes, ENTRY_TYPES[values["OBJECTTYPE"]]["name"]))
             # Verify that parameters defined are all in the possible parameters
             if not keys.issubset(possible):
                 unsupported = keys.difference(possible)
@@ -392,7 +392,7 @@ def ParseEDSFile(filepath):
                     attributes = _("Attributes %s are")%_(", ").join(["\"%s\""%attribute for attribute in unsupported])
                 else:
                     attributes = _("Attribute \"%s\" is")%unsupported.pop()
-                raise SyntaxError, _("Error on section \"[%s]\":\n%s unsupported for a %s entry")%(section_name, attributes, ENTRY_TYPES[values["OBJECTTYPE"]]["name"])
+                raise SyntaxError(_("Error on section \"[%s]\":\n%s unsupported for a %s entry")%(section_name, attributes, ENTRY_TYPES[values["OBJECTTYPE"]]["name"]))
             
             VerifyValue(values, section_name, "ParameterValue")
             VerifyValue(values, section_name, "DefaultValue")
@@ -409,10 +409,10 @@ def VerifyValue(values, section_name, param):
             elif values["DATATYPE"] == 0x01:
                 values[param.upper()] = {0 : False, 1 : True}[values[param.upper()]]
             else:
-                if not isinstance(values[param.upper()], (IntType, LongType)) and values[param.upper()].upper().find("$NODEID") == -1:
+                if not isinstance(values[param.upper()], int) and values[param.upper()].upper().find("$NODEID") == -1:
                     raise
         except:
-            raise SyntaxError, _("Error on section \"[%s]\":\n%s incompatible with DataType")%(section_name, param)
+            raise SyntaxError(_("Error on section \"[%s]\":\n%s incompatible with DataType")%(section_name, param))
 
 
 # Function that write an EDS file after generate it's content
@@ -531,7 +531,7 @@ def GenerateFileContent(Node, filepath):
         # Define section name
         text = "\n[%X]\n"%entry
         # If there is only one value, it's a VAR entry
-        if type(values) != ListType:
+        if type(values) != list:
             # Extract the informations of the first subindex
             subentry_infos = Node.GetSubentryInfos(entry, 0)
             # Generate EDS informations for the entry
@@ -636,7 +636,7 @@ def GenerateEDSFile(filepath, node):
         # Write file
         WriteFile(filepath, content)
         return None
-    except ValueError, message:
+    except ValueError as essage:
         return _("Unable to generate EDS file\n%s")%message
     
 # Function that generate the CPJ file content for the nodelist
@@ -696,7 +696,7 @@ def GenerateNode(filepath, nodeID = 0):
                         if values["OBJECTTYPE"] == 2:
                             values["DATATYPE"] = values.get("DATATYPE", 0xF)
                             if values["DATATYPE"] != 0xF:
-                                raise SyntaxError, _("Domain entry 0x%4.4X DataType must be 0xF(DOMAIN) if defined")%entry
+                                raise SyntaxError(_("Domain entry 0x%4.4X DataType must be 0xF(DOMAIN) if defined")%entry)
                         # Add mapping for entry
                         Node.AddMappingEntry(entry, name = values["PARAMETERNAME"], struct = 1)
                         # Add mapping for first subindex
@@ -713,7 +713,7 @@ def GenerateNode(filepath, nodeID = 0):
                         # Add mapping for first subindex
                         Node.AddMappingEntry(entry, 0, values = {"name" : "Number of Entries", "type" : 0x05, "access" : "ro", "pdo" : False})
                         # Add mapping for other subindexes
-                        for subindex in xrange(1, int(max_subindex) + 1):
+                        for subindex in range(1, int(max_subindex) + 1):
                             # if subindex is defined
                             if subindex in values["subindexes"]:
                                 Node.AddMappingEntry(entry, subindex, values = {"name" : values["subindexes"][subindex]["PARAMETERNAME"], 
@@ -727,7 +727,7 @@ def GenerateNode(filepath, nodeID = 0):
 ##                    elif values["OBJECTTYPE"] == 9:
 ##                        # Verify that the first subindex is defined
 ##                        if 0 not in values["subindexes"]:
-##                            raise SyntaxError, "Error on entry 0x%4.4X:\nSubindex 0 must be defined for a RECORD entry"%entry
+##                            raise SyntaxError("Error on entry 0x%4.4X:\nSubindex 0 must be defined for a RECORD entry"%entry)
 ##                        # Add mapping for entry
 ##                        Node.AddMappingEntry(entry, name = values["PARAMETERNAME"], struct = 7)
 ##                        # Add mapping for first subindex
@@ -740,7 +740,7 @@ def GenerateNode(filepath, nodeID = 0):
 ##                                                                     "pdo" : values["subindexes"][1].get("PDOMAPPING", 0) == 1,
 ##                                                                     "nbmax" : 0xFE})
 ##                        else:
-##                            raise SyntaxError, "Error on entry 0x%4.4X:\nA RECORD entry must have at least 2 subindexes"%entry
+##                            raise SyntaxError("Error on entry 0x%4.4X:\nA RECORD entry must have at least 2 subindexes"%entry)
                 
                 # Define entry for the new node
                 
@@ -763,7 +763,7 @@ def GenerateNode(filepath, nodeID = 0):
                         max_subindex = max(values["subindexes"].keys())
                         Node.AddEntry(entry, value = [])
                         # Define value for all subindexes except the first 
-                        for subindex in xrange(1, int(max_subindex) + 1):
+                        for subindex in range(1, int(max_subindex) + 1):
                             # Take default value if it is defined and entry is defined
                             if subindex in values["subindexes"] and "PARAMETERVALUE" in values["subindexes"][subindex]:
                                 value = values["subindexes"][subindex]["PARAMETERVALUE"]
@@ -774,9 +774,9 @@ def GenerateNode(filepath, nodeID = 0):
                                 value = GetDefaultValue(Node, entry, subindex)
                             Node.AddEntry(entry, subindex, value)
                     else:
-                        raise SyntaxError, _("Array or Record entry 0x%4.4X must have a \"SubNumber\" attribute")%entry
+                        raise SyntaxError(_("Array or Record entry 0x%4.4X must have a \"SubNumber\" attribute")%entry)
         return Node
-    except SyntaxError, message:
+    except SyntaxError as message:
         return _("Unable to import EDS file\n%s")%message
 
 #-------------------------------------------------------------------------------
@@ -784,5 +784,5 @@ def GenerateNode(filepath, nodeID = 0):
 #-------------------------------------------------------------------------------
 
 if __name__ == '__main__':
-    print ParseEDSFile("examples/PEAK MicroMod.eds")
+    print(ParseEDSFile("examples/PEAK MicroMod.eds"))
 
diff --git a/objdictgen/gen_cfile.py b/objdictgen/gen_cfile.py
index 0945f52dc405..be452121fce9 100644
--- a/objdictgen/gen_cfile.py
+++ b/objdictgen/gen_cfile.py
@@ -61,9 +61,9 @@ def GetValidTypeInfos(typename, items=[]):
         result = type_model.match(typename)
         if result:
             values = result.groups()
-            if values[0] == "UNSIGNED" and int(values[1]) in [i * 8 for i in xrange(1, 9)]:
+            if values[0] == "UNSIGNED" and int(values[1]) in [i * 8 for i in range(1, 9)]:
                 typeinfos = ("UNS%s"%values[1], None, "uint%s"%values[1], True)
-            elif values[0] == "INTEGER" and int(values[1]) in [i * 8 for i in xrange(1, 9)]:
+            elif values[0] == "INTEGER" and int(values[1]) in [i * 8 for i in range(1, 9)]:
                 typeinfos = ("INTEGER%s"%values[1], None, "int%s"%values[1], False)
             elif values[0] == "REAL" and int(values[1]) in (32, 64):
                 typeinfos = ("%s%s"%(values[0], values[1]), None, "real%s"%values[1], False)
@@ -82,11 +82,11 @@ def GetValidTypeInfos(typename, items=[]):
             elif values[0] == "BOOLEAN":
                 typeinfos = ("UNS8", None, "boolean", False)
             else:
-                raise ValueError, _("""!!! %s isn't a valid type for CanFestival.""")%typename
+                raise ValueError(_("""!!! %s isn't a valid type for CanFestival.""")%typename)
             if typeinfos[2] not in ["visible_string", "domain"]:
                 internal_types[typename] = typeinfos
         else:
-            raise ValueError, _("""!!! %s isn't a valid type for CanFestival.""")%typename
+            raise ValueError(_("""!!! %s isn't a valid type for CanFestival.""")%typename)
     return typeinfos
 
 def ComputeValue(type, value):
@@ -107,7 +107,7 @@ def WriteFile(filepath, content):
 def GetTypeName(Node, typenumber):
     typename = Node.GetTypeName(typenumber)
     if typename is None:
-        raise ValueError, _("""!!! Datatype with value "0x%4.4X" isn't defined in CanFestival.""")%typenumber
+        raise ValueError(_("""!!! Datatype with value "0x%4.4X" isn't defined in CanFestival.""")%typenumber)
     return typename
 
 def GenerateFileContent(Node, headerfilepath, pointers_dict = {}):
@@ -189,7 +189,7 @@ def GenerateFileContent(Node, headerfilepath, pointers_dict = {}):
         texts["index"] = index
         strIndex = ""
         entry_infos = Node.GetEntryInfos(index)
-        texts["EntryName"] = entry_infos["name"].encode('ascii','replace')
+        texts["EntryName"] = entry_infos["name"]
         values = Node.GetEntry(index)
         callbacks = Node.HasEntryCallbacks(index)
         if index in variablelist:
@@ -198,13 +198,13 @@ def GenerateFileContent(Node, headerfilepath, pointers_dict = {}):
             strIndex += "\n/* index 0x%(index)04X :   %(EntryName)s. */\n"%texts
         
         # Entry type is VAR
-        if not isinstance(values, ListType):
+        if not isinstance(values, list):
             subentry_infos = Node.GetSubentryInfos(index, 0)
             typename = GetTypeName(Node, subentry_infos["type"])
             typeinfos = GetValidTypeInfos(typename, [values])
             if typename is "DOMAIN" and index in variablelist:
                 if not typeinfos[1]:
-                    raise ValueError, _("\nDomain variable not initialized\nindex : 0x%04X\nsubindex : 0x00")%index
+                    raise ValueError(_("\nDomain variable not initialized\nindex : 0x%04X\nsubindex : 0x00")%index)
             texts["subIndexType"] = typeinfos[0]
             if typeinfos[1] is not None:
                 texts["suffixe"] = "[%d]"%typeinfos[1]
@@ -298,14 +298,14 @@ def GenerateFileContent(Node, headerfilepath, pointers_dict = {}):
                 name = "%(NodeName)s_Index%(index)04X"%texts
             name=UnDigitName(name);
             strIndex += "                    ODCallback_t %s_callbacks[] = \n                     {\n"%name
-            for subIndex in xrange(len(values)):
+            for subIndex in range(len(values)):
                 strIndex += "                       NULL,\n"
             strIndex += "                     };\n"
             indexCallbacks[index] = "*callbacks = %s_callbacks; "%name
         else:
             indexCallbacks[index] = ""
         strIndex += "                    subindex %(NodeName)s_Index%(index)04X[] = \n                     {\n"%texts
-        for subIndex in xrange(len(values)):
+        for subIndex in range(len(values)):
             subentry_infos = Node.GetSubentryInfos(index, subIndex)
             if subIndex < len(values) - 1:
                 sep = ","
@@ -514,8 +514,7 @@ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 */
 """%texts
-    contentlist = indexContents.keys()
-    contentlist.sort()
+    contentlist = sorted(indexContents.keys())
     for index in contentlist:
         fileContent += indexContents[index]
 
@@ -600,6 +599,6 @@ def GenerateFile(filepath, node, pointers_dict = {}):
         WriteFile(filepath, content)
         WriteFile(headerfilepath, header)
         return None
-    except ValueError, message:
+    except ValueError as message:
         return _("Unable to Generate C File\n%s")%message
 
diff --git a/objdictgen/networkedit.py b/objdictgen/networkedit.py
index 6577d6f9760b..2ba72e6962e1 100644
--- a/objdictgen/networkedit.py
+++ b/objdictgen/networkedit.py
@@ -541,13 +541,13 @@ class networkedit(wx.Frame, NetworkEditorTemplate):
                 find_index = True
                 index, subIndex = result
                 result = OpenPDFDocIndex(index, ScriptDirectory)
-                if isinstance(result, (StringType, UnicodeType)):
+                if isinstance(result, str):
                     message = wx.MessageDialog(self, result, _("ERROR"), wx.OK|wx.ICON_ERROR)
                     message.ShowModal()
                     message.Destroy()
         if not find_index:
             result = OpenPDFDocIndex(None, ScriptDirectory)
-            if isinstance(result, (StringType, UnicodeType)):
+            if isinstance(result, str):
                 message = wx.MessageDialog(self, result, _("ERROR"), wx.OK|wx.ICON_ERROR)
                 message.ShowModal()
                 message.Destroy()
diff --git a/objdictgen/node.py b/objdictgen/node.py
index e73dacbe8248..acaf558a00c6 100755
--- a/objdictgen/node.py
+++ b/objdictgen/node.py
@@ -21,7 +21,7 @@
 #License along with this library; if not, write to the Free Software
 #Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
-import cPickle
+import _pickle as cPickle
 from types import *
 import re
 
@@ -348,7 +348,7 @@ def FindMapVariableList(mappingdictionary, Node, compute=True):
                     name = mappingdictionary[index]["values"][subIndex]["name"]
                     if mappingdictionary[index]["struct"] & OD_IdenticalSubindexes:
                         values = Node.GetEntry(index)
-                        for i in xrange(len(values) - 1):
+                        for i in range(len(values) - 1):
                             computed_name = name
                             if compute:
                                 computed_name = StringFormat(computed_name, 1, i + 1)
@@ -568,7 +568,7 @@ class Node:
             elif subIndex == 1:
                 self.Dictionary[index] = [value]
                 return True
-        elif subIndex > 0 and type(self.Dictionary[index]) == ListType and subIndex == len(self.Dictionary[index]) + 1:
+        elif subIndex > 0 and type(self.Dictionary[index]) == list and subIndex == len(self.Dictionary[index]) + 1:
             self.Dictionary[index].append(value)
             return True
         return False
@@ -582,7 +582,7 @@ class Node:
                 if value != None:
                     self.Dictionary[index] = value
                 return True
-            elif type(self.Dictionary[index]) == ListType and 0 < subIndex <= len(self.Dictionary[index]):
+            elif type(self.Dictionary[index]) == list and 0 < subIndex <= len(self.Dictionary[index]):
                 if value != None:
                     self.Dictionary[index][subIndex - 1] = value
                 return True
@@ -594,7 +594,7 @@ class Node:
         if index in self.Dictionary:
             if (comment != None or save != None or callback != None) and index not in self.ParamsDictionary:
                 self.ParamsDictionary[index] = {}
-            if subIndex == None or type(self.Dictionary[index]) != ListType and subIndex == 0:
+            if subIndex == None or type(self.Dictionary[index]) != list and subIndex == 0:
                 if comment != None:
                     self.ParamsDictionary[index]["comment"] = comment
                 if save != None:
@@ -602,7 +602,7 @@ class Node:
                 if callback != None:
                     self.ParamsDictionary[index]["callback"] = callback
                 return True
-            elif type(self.Dictionary[index]) == ListType and 0 <= subIndex <= len(self.Dictionary[index]):
+            elif type(self.Dictionary[index]) == list and 0 <= subIndex <= len(self.Dictionary[index]):
                 if (comment != None or save != None or callback != None) and subIndex not in self.ParamsDictionary[index]:
                     self.ParamsDictionary[index][subIndex] = {}
                 if comment != None:
@@ -626,7 +626,7 @@ class Node:
                 if index in self.ParamsDictionary:
                     self.ParamsDictionary.pop(index)
                 return True
-            elif type(self.Dictionary[index]) == ListType and subIndex == len(self.Dictionary[index]):
+            elif type(self.Dictionary[index]) == list and subIndex == len(self.Dictionary[index]):
                 self.Dictionary[index].pop(subIndex - 1)
                 if index in self.ParamsDictionary:
                     if subIndex in self.ParamsDictionary[index]:
@@ -657,7 +657,7 @@ class Node:
     def GetEntry(self, index, subIndex = None, compute = True):
         if index in self.Dictionary:
             if subIndex == None:
-                if type(self.Dictionary[index]) == ListType:
+                if type(self.Dictionary[index]) == list:
                     values = [len(self.Dictionary[index])]
                     for value in self.Dictionary[index]:
                         values.append(self.CompileValue(value, index, compute))
@@ -665,11 +665,11 @@ class Node:
                 else:
                     return self.CompileValue(self.Dictionary[index], index, compute)
             elif subIndex == 0:
-                if type(self.Dictionary[index]) == ListType:
+                if type(self.Dictionary[index]) == list:
                     return len(self.Dictionary[index])
                 else:
                     return self.CompileValue(self.Dictionary[index], index, compute)
-            elif type(self.Dictionary[index]) == ListType and 0 < subIndex <= len(self.Dictionary[index]):
+            elif type(self.Dictionary[index]) == list and 0 < subIndex <= len(self.Dictionary[index]):
                 return self.CompileValue(self.Dictionary[index][subIndex - 1], index, compute)
         return None
 
@@ -682,28 +682,28 @@ class Node:
             self.ParamsDictionary = {}
         if index in self.Dictionary:
             if subIndex == None:
-                if type(self.Dictionary[index]) == ListType:
+                if type(self.Dictionary[index]) == list:
                     if index in self.ParamsDictionary:
                         result = []
-                        for i in xrange(len(self.Dictionary[index]) + 1):
+                        for i in range(len(self.Dictionary[index]) + 1):
                             line = DefaultParams.copy()
                             if i in self.ParamsDictionary[index]:
                                 line.update(self.ParamsDictionary[index][i])
                             result.append(line)
                         return result
                     else:
-                        return [DefaultParams.copy() for i in xrange(len(self.Dictionary[index]) + 1)]
+                        return [DefaultParams.copy() for i in range(len(self.Dictionary[index]) + 1)]
                 else:
                     result = DefaultParams.copy()
                     if index in self.ParamsDictionary:
                         result.update(self.ParamsDictionary[index])
                     return result
-            elif subIndex == 0 and type(self.Dictionary[index]) != ListType:
+            elif subIndex == 0 and type(self.Dictionary[index]) != list:
                 result = DefaultParams.copy()
                 if index in self.ParamsDictionary:
                     result.update(self.ParamsDictionary[index])
                 return result
-            elif type(self.Dictionary[index]) == ListType and 0 <= subIndex <= len(self.Dictionary[index]):
+            elif type(self.Dictionary[index]) == list and 0 <= subIndex <= len(self.Dictionary[index]):
                 result = DefaultParams.copy()
                 if index in self.ParamsDictionary and subIndex in self.ParamsDictionary[index]:
                     result.update(self.ParamsDictionary[index][subIndex])
@@ -780,23 +780,23 @@ class Node:
                     if self.UserMapping[index]["struct"] & OD_IdenticalSubindexes:
                         if self.IsStringType(self.UserMapping[index]["values"][subIndex]["type"]):
                             if self.IsRealType(values["type"]):
-                                for i in xrange(len(self.Dictionary[index])):
+                                for i in range(len(self.Dictionary[index])):
                                     self.SetEntry(index, i + 1, 0.)
                             elif not self.IsStringType(values["type"]):
-                                for i in xrange(len(self.Dictionary[index])):
+                                for i in range(len(self.Dictionary[index])):
                                     self.SetEntry(index, i + 1, 0)
                         elif self.IsRealType(self.UserMapping[index]["values"][subIndex]["type"]):
                             if self.IsStringType(values["type"]):
-                                for i in xrange(len(self.Dictionary[index])):
+                                for i in range(len(self.Dictionary[index])):
                                     self.SetEntry(index, i + 1, "")
                             elif not self.IsRealType(values["type"]):
-                                for i in xrange(len(self.Dictionary[index])):
+                                for i in range(len(self.Dictionary[index])):
                                     self.SetEntry(index, i + 1, 0)
                         elif self.IsStringType(values["type"]):
-                            for i in xrange(len(self.Dictionary[index])):
+                            for i in range(len(self.Dictionary[index])):
                                 self.SetEntry(index, i + 1, "")
                         elif self.IsRealType(values["type"]):
-                            for i in xrange(len(self.Dictionary[index])):
+                            for i in range(len(self.Dictionary[index])):
                                 self.SetEntry(index, i + 1, 0.)                        
                     else:
                         if self.IsStringType(self.UserMapping[index]["values"][subIndex]["type"]):
@@ -883,14 +883,13 @@ class Node:
     """
     def GetIndexes(self):
         listindex = self.Dictionary.keys()
-        listindex.sort()
-        return listindex
+        return sorted(listindex)
 
     """
     Print the Dictionary values
     """
     def Print(self):
-        print self.PrintString()
+        print(self.PrintString())
     
     def PrintString(self):
         result = ""
@@ -899,7 +898,7 @@ class Node:
         for index in listindex:
             name = self.GetEntryName(index)
             values = self.Dictionary[index]
-            if isinstance(values, ListType):
+            if isinstance(values, list):
                 result += "%04X (%s):\n"%(index, name)
                 for subidx, value in enumerate(values):
                     subentry_infos = self.GetSubentryInfos(index, subidx + 1)
@@ -918,17 +917,17 @@ class Node:
                             value += (" %0"+"%d"%(size * 2)+"X")%BE_to_LE(data[i+7:i+7+size])
                             i += 7 + size
                             count += 1
-                    elif isinstance(value, IntType):
+                    elif isinstance(value, int):
                         value = "%X"%value
                     result += "%04X %02X (%s): %s\n"%(index, subidx+1, subentry_infos["name"], value)
             else:
-                if isinstance(values, IntType):
+                if isinstance(values, int):
                     values = "%X"%values
                 result += "%04X (%s): %s\n"%(index, name, values)
         return result
             
     def CompileValue(self, value, index, compute = True):
-        if isinstance(value, (StringType, UnicodeType)) and value.upper().find("$NODEID") != -1:
+        if isinstance(value, str) and value.upper().find("$NODEID") != -1:
             base = self.GetBaseIndex(index)
             try:
                 raw = eval(value)
@@ -1153,7 +1152,7 @@ def LE_to_BE(value, size):
     """
     
     data = ("%" + str(size * 2) + "." + str(size * 2) + "X") % value
-    list_car = [data[i:i+2] for i in xrange(0, len(data), 2)]
+    list_car = [data[i:i+2] for i in range(0, len(data), 2)]
     list_car.reverse()
     return "".join([chr(int(car, 16)) for car in list_car])
 
diff --git a/objdictgen/nodeeditortemplate.py b/objdictgen/nodeeditortemplate.py
index 462455f01df1..dc7c3743620d 100644
--- a/objdictgen/nodeeditortemplate.py
+++ b/objdictgen/nodeeditortemplate.py
@@ -83,10 +83,10 @@ class NodeEditorTemplate:
                 text = _("%s: %s entry of struct %s%s.")%(name,category,struct,number)
                 self.Frame.HelpBar.SetStatusText(text, 2)
             else:
-                for i in xrange(3):
+                for i in range(3):
                     self.Frame.HelpBar.SetStatusText("", i)
         else:
-            for i in xrange(3):
+            for i in range(3):
                 self.Frame.HelpBar.SetStatusText("", i)
     
     def RefreshProfileMenu(self):
@@ -95,7 +95,7 @@ class NodeEditorTemplate:
             edititem = self.Frame.EditMenu.FindItemById(self.EDITMENU_ID)
             if edititem:
                 length = self.Frame.AddMenu.GetMenuItemCount()
-                for i in xrange(length-6):
+                for i in range(length-6):
                     additem = self.Frame.AddMenu.FindItemByPosition(6)
                     self.Frame.AddMenu.Delete(additem.GetId())
                 if profile not in ("None", "DS-301"):
@@ -201,7 +201,7 @@ class NodeEditorTemplate:
             dialog.SetIndex(index)
             if dialog.ShowModal() == wx.ID_OK:
                 result = self.Manager.AddMapVariableToCurrent(*dialog.GetValues())
-                if not isinstance(result, (StringType, UnicodeType)):
+                if not isinstance(result, str):
                     self.RefreshBufferState()
                     self.RefreshCurrentIndexList()
                 else:
@@ -215,7 +215,7 @@ class NodeEditorTemplate:
         dialog.SetTypeList(self.Manager.GetCustomisableTypes())
         if dialog.ShowModal() == wx.ID_OK:
             result = self.Manager.AddUserTypeToCurrent(*dialog.GetValues())
-            if not isinstance(result, (StringType, UnicodeType)):
+            if not isinstance(result, str):
                 self.RefreshBufferState()
                 self.RefreshCurrentIndexList()
             else:
diff --git a/objdictgen/nodelist.py b/objdictgen/nodelist.py
index 97576ac24210..d1356434fe97 100644
--- a/objdictgen/nodelist.py
+++ b/objdictgen/nodelist.py
@@ -184,7 +184,7 @@ class NodeList:
             result = self.Manager.OpenFileInCurrent(masterpath)
         else:
             result = self.Manager.CreateNewNode("MasterNode", 0x00, "master", "", "None", "", "heartbeat", ["DS302"])
-        if not isinstance(result, types.IntType):
+        if not isinstance(result, int):
             return result
         return None
     
diff --git a/objdictgen/nodemanager.py b/objdictgen/nodemanager.py
index 8ad5d83b430e..9394e05e76cd 100755
--- a/objdictgen/nodemanager.py
+++ b/objdictgen/nodemanager.py
@@ -31,6 +31,8 @@ import eds_utils, gen_cfile
 from types import *
 import os, re
 
+_ = lambda x: x
+
 UndoBufferLength = 20
 
 type_model = re.compile('([\_A-Z]*)([0-9]*)')
@@ -65,7 +67,7 @@ class UndoBuffer:
             self.MinIndex = 0
             self.MaxIndex = 0
         # Initialising buffer with currentstate at the first place
-        for i in xrange(UndoBufferLength):
+        for i in range(UndoBufferLength):
             if i == 0:
                 self.Buffer.append(currentstate)
             else:
@@ -285,7 +287,8 @@ class NodeManager:
             self.SetCurrentFilePath(filepath)
             return index
         except:
-            return _("Unable to load file \"%s\"!")%filepath
+            print( _("Unable to load file \"%s\"!")%filepath)
+            raise
 
     """
     Save current node in  a file
@@ -378,7 +381,7 @@ class NodeManager:
             default = self.GetTypeDefaultValue(subentry_infos["type"])   
         # First case entry is record
         if infos["struct"] & OD_IdenticalSubindexes: 
-            for i in xrange(1, min(number,subentry_infos["nbmax"]-length) + 1):
+            for i in range(1, min(number,subentry_infos["nbmax"]-length) + 1):
                 node.AddEntry(index, length + i, default)
             if not disable_buffer:
                 self.BufferCurrentNode()
@@ -386,7 +389,7 @@ class NodeManager:
         # Second case entry is array, only possible for manufacturer specific
         elif infos["struct"] & OD_MultipleSubindexes and 0x2000 <= index <= 0x5FFF:
             values = {"name" : "Undefined", "type" : 5, "access" : "rw", "pdo" : True}
-            for i in xrange(1, min(number,0xFE-length) + 1):
+            for i in range(1, min(number,0xFE-length) + 1):
                 node.AddMappingEntry(index, length + i, values = values.copy())
                 node.AddEntry(index, length + i, 0)
             if not disable_buffer:
@@ -408,7 +411,7 @@ class NodeManager:
             nbmin = 1
         # Entry is a record, or is an array of manufacturer specific
         if infos["struct"] & OD_IdenticalSubindexes or 0x2000 <= index <= 0x5FFF and infos["struct"] & OD_IdenticalSubindexes:
-            for i in xrange(min(number, length - nbmin)):
+            for i in range(min(number, length - nbmin)):
                 self.RemoveCurrentVariable(index, length - i)
             self.BufferCurrentNode()
 
@@ -497,7 +500,7 @@ class NodeManager:
                         default = self.GetTypeDefaultValue(subentry_infos["type"])
                     node.AddEntry(index, value = [])
                     if "nbmin" in subentry_infos:
-                        for i in xrange(subentry_infos["nbmin"]):
+                        for i in range(subentry_infos["nbmin"]):
                             node.AddEntry(index, i + 1, default)
                     else:
                         node.AddEntry(index, 1, default)
@@ -581,7 +584,7 @@ class NodeManager:
             for menu,list in self.CurrentNode.GetSpecificMenu():
                 for i in list:
                     iinfos = self.GetEntryInfos(i)
-                    indexes = [i + incr * iinfos["incr"] for incr in xrange(iinfos["nbmax"])] 
+                    indexes = [i + incr * iinfos["incr"] for incr in range(iinfos["nbmax"])]
                     if index in indexes:
                         found = True
                         diff = index - i
@@ -613,10 +616,10 @@ class NodeManager:
                     if struct == rec:
                         values = {"name" : name + " %d[(sub)]", "type" : 0x05, "access" : "rw", "pdo" : True, "nbmax" : 0xFE}
                         node.AddMappingEntry(index, 1, values = values)
-                        for i in xrange(number):
+                        for i in range(number):
                             node.AddEntry(index, i + 1, 0)
                     else:
-                        for i in xrange(number):
+                        for i in range(number):
                             values = {"name" : "Undefined", "type" : 0x05, "access" : "rw", "pdo" : True}
                             node.AddMappingEntry(index, i + 1, values = values)
                             node.AddEntry(index, i + 1, 0)
@@ -1029,7 +1032,7 @@ class NodeManager:
             editors = []
             values = node.GetEntry(index, compute = False)
             params = node.GetParamsEntry(index)
-            if isinstance(values, ListType):
+            if isinstance(values, list):
                 for i, value in enumerate(values):
                     data.append({"value" : value})
                     data[-1].update(params[i])      
@@ -1049,7 +1052,7 @@ class NodeManager:
                           "type" : None, "value" : None,
                           "access" : None, "save" : "option", 
                           "callback" : "option", "comment" : "string"}
-                if isinstance(values, ListType) and i == 0:
+                if isinstance(values, list) and i == 0:
                     if 0x1600 <= index <= 0x17FF or 0x1A00 <= index <= 0x1C00:
                         editor["access"] = "raccess"
                 else:
diff --git a/objdictgen/objdictedit.py b/objdictgen/objdictedit.py
index 9efb1ae83c0b..1a356fa2e7c5 100755
--- a/objdictgen/objdictedit.py
+++ b/objdictgen/objdictedit.py
@@ -30,8 +30,8 @@ __version__ = "$Revision: 1.48 $"
 
 if __name__ == '__main__':
     def usage():
-        print _("\nUsage of objdictedit.py :")
-        print "\n   %s [Filepath, ...]\n"%sys.argv[0]
+        print(_("\nUsage of objdictedit.py :"))
+        print("\n   %s [Filepath, ...]\n"%sys.argv[0])
 
     try:
         opts, args = getopt.getopt(sys.argv[1:], "h", ["help"])
@@ -343,7 +343,7 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
         if self.ModeSolo:
             for filepath in filesOpen:
                 result = self.Manager.OpenFileInCurrent(os.path.abspath(filepath))
-                if isinstance(result, (IntType, LongType)):
+                if isinstance(result, int):
                     new_editingpanel = EditingPanel(self.FileOpened, self, self.Manager)
                     new_editingpanel.SetIndex(result)
                     self.FileOpened.AddPage(new_editingpanel, "")
@@ -392,13 +392,13 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
                 find_index = True
                 index, subIndex = result
                 result = OpenPDFDocIndex(index, ScriptDirectory)
-                if isinstance(result, (StringType, UnicodeType)):
+                if isinstance(result, str):
                     message = wx.MessageDialog(self, result, _("ERROR"), wx.OK|wx.ICON_ERROR)
                     message.ShowModal()
                     message.Destroy()
         if not find_index:
             result = OpenPDFDocIndex(None, ScriptDirectory)
-            if isinstance(result, (StringType, UnicodeType)):
+            if isinstance(result, str):
                 message = wx.MessageDialog(self, result, _("ERROR"), wx.OK|wx.ICON_ERROR)
                 message.ShowModal()
                 message.Destroy()
@@ -448,7 +448,7 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
             answer = dialog.ShowModal()
             dialog.Destroy()
             if answer == wx.ID_YES:
-                for i in xrange(self.Manager.GetBufferNumber()):
+                for i in range(self.Manager.GetBufferNumber()):
                     if self.Manager.CurrentIsSaved():
                         self.Manager.CloseCurrent()
                     else:
@@ -542,7 +542,7 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
             NMT = dialog.GetNMTManagement()
             options = dialog.GetOptions()
             result = self.Manager.CreateNewNode(name, id, nodetype, description, profile, filepath, NMT, options)
-            if isinstance(result, (IntType, LongType)):
+            if isinstance(result, int):
                 new_editingpanel = EditingPanel(self.FileOpened, self, self.Manager)
                 new_editingpanel.SetIndex(result)
                 self.FileOpened.AddPage(new_editingpanel, "")
@@ -570,7 +570,7 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
             filepath = dialog.GetPath()
             if os.path.isfile(filepath):
                 result = self.Manager.OpenFileInCurrent(filepath)
-                if isinstance(result, (IntType, LongType)):
+                if isinstance(result, int):
                     new_editingpanel = EditingPanel(self.FileOpened, self, self.Manager)
                     new_editingpanel.SetIndex(result)
                     self.FileOpened.AddPage(new_editingpanel, "")
@@ -603,7 +603,7 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
         result = self.Manager.SaveCurrentInFile()
         if not result:
             self.SaveAs()
-        elif not isinstance(result, (StringType, UnicodeType)):
+        elif not isinstance(result, str):
             self.RefreshBufferState()
         else:
             message = wx.MessageDialog(self, result, _("Error"), wx.OK|wx.ICON_ERROR)
@@ -621,7 +621,7 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
             filepath = dialog.GetPath()
             if os.path.isdir(os.path.dirname(filepath)):
                 result = self.Manager.SaveCurrentInFile(filepath)
-                if not isinstance(result, (StringType, UnicodeType)):
+                if not isinstance(result, str):
                     self.RefreshBufferState()
                 else:
                     message = wx.MessageDialog(self, result, _("Error"), wx.OK|wx.ICON_ERROR)
@@ -665,7 +665,7 @@ class objdictedit(wx.Frame, NodeEditorTemplate):
             filepath = dialog.GetPath()
             if os.path.isfile(filepath):
                 result = self.Manager.ImportCurrentFromEDSFile(filepath)
-                if isinstance(result, (IntType, LongType)):
+                if isinstance(result, int):
                     new_editingpanel = EditingPanel(self.FileOpened, self, self.Manager)
                     new_editingpanel.SetIndex(result)
                     self.FileOpened.AddPage(new_editingpanel, "")
diff --git a/objdictgen/objdictgen.py b/objdictgen/objdictgen.py
index 9d5131b7a8c9..6dd88737fa18 100644
--- a/objdictgen/objdictgen.py
+++ b/objdictgen/objdictgen.py
@@ -29,8 +29,8 @@ from nodemanager import *
 _ = lambda x: x
 
 def usage():
-    print _("\nUsage of objdictgen.py :")
-    print "\n   %s XMLFilePath CFilePath\n"%sys.argv[0]
+    print(_("\nUsage of objdictgen.py :"))
+    print("\n   %s XMLFilePath CFilePath\n"%sys.argv[0])
 
 try:
     opts, args = getopt.getopt(sys.argv[1:], "h", ["help"])
@@ -57,20 +57,20 @@ if __name__ == '__main__':
     if fileIn != "" and fileOut != "":
         manager = NodeManager()
         if os.path.isfile(fileIn):
-            print _("Parsing input file")
+            print(_("Parsing input file"))
             result = manager.OpenFileInCurrent(fileIn)
-            if not isinstance(result, (StringType, UnicodeType)):
+            if not isinstance(result, str):
                 Node = result
             else:
-                print result
+                print(result)
                 sys.exit(-1)
         else:
-            print _("%s is not a valid file!")%fileIn
+            print(_("%s is not a valid file!")%fileIn)
             sys.exit(-1)
-        print _("Writing output file")
+        print(_("Writing output file"))
         result = manager.ExportCurrentToCFile(fileOut)
-        if isinstance(result, (UnicodeType, StringType)):
-            print result
+        if isinstance(result, str):
+            print(result)
             sys.exit(-1)
-        print _("All done")
+        print(_("All done"))
     
