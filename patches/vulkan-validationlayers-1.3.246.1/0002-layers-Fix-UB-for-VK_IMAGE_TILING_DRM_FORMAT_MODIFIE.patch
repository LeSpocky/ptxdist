From: Niklas Haas <git@haasn.dev>
Date: Thu, 20 Apr 2023 11:51:49 +0200
Subject: [PATCH] layers: Fix UB for VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT

Several codepaths in the layers called into
vkGetPhysicalDeviceImageFormatProperties2KHR without including a valid
VkPhysicalDeviceImageDrmFormatModifierInfoEXT, despite this being a
requirement for images with DRM format modifier tiling.

For the vkBindImageMemory check, there is a hypothetical possibility of
the driver returning VK_ERROR_OUT_OF_HOST_MEMORY when querying the
image's DRM format. In this case, for lack of anything better to do, we
preserve the current behavior.

It might make more sense to query the DRM format modifier immediately
after image creation and cache it inside the image state, but I didn't
want to make that (more invasive) change myself.

As an aside, we also correctly specify the specified `sharingMode` when
querying for DRM modifier support, which the current code failed to do
properly.

Co-authored-by: Simon Ser <contact@emersion.fr>

closes #5649
closes #5687

(cherry picked from commit ce2c6eff3457a331efd64da800c5ac393285cf40)

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 layers/core_checks/device_memory_validation.cpp | 18 ++++++-
 layers/core_checks/image_validation.cpp         | 72 ++++++++++++++++---------
 2 files changed, 62 insertions(+), 28 deletions(-)

diff --git a/layers/core_checks/device_memory_validation.cpp b/layers/core_checks/device_memory_validation.cpp
index 4a98d6f0922d..555985957dce 100644
--- a/layers/core_checks/device_memory_validation.cpp
+++ b/layers/core_checks/device_memory_validation.cpp
@@ -887,7 +887,7 @@ bool CoreChecks::PreCallValidateMapMemory(VkDevice device, VkDeviceMemory mem, V
     return skip;
 }
 
-bool CoreChecks::PreCallValidateMapMemory2KHR(VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void **ppData) const {
+bool CoreChecks::PreCallValidateMapMemory2KHR(VkDevice device, const VkMemoryMapInfoKHR *pMemoryMapInfo, void **ppData) const {
     bool skip = false;
     auto mem_info = Get<DEVICE_MEMORY_STATE>(pMemoryMapInfo->memory);
     if (mem_info) {
@@ -905,7 +905,7 @@ bool CoreChecks::PreCallValidateUnmapMemory(VkDevice device, VkDeviceMemory mem)
     return skip;
 }
 
-bool CoreChecks::PreCallValidateUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo) const {
+bool CoreChecks::PreCallValidateUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfoKHR *pMemoryUnmapInfo) const {
     bool skip = false;
     auto mem_info = Get<DEVICE_MEMORY_STATE>(pMemoryUnmapInfo->memory);
     if (mem_info && !mem_info->mapped_range.size) {
@@ -1269,6 +1269,10 @@ bool CoreChecks::ValidateBindImageMemory(uint32_t bindInfoCount, const VkBindIma
 
                 // Validate export memory handles
                 if (mem_info->export_handle_type_flags != 0) {
+                    auto drm_format_modifier = LvlInitStruct<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>();
+                    drm_format_modifier.sharingMode = image_state->createInfo.sharingMode;
+                    drm_format_modifier.queueFamilyIndexCount = image_state->createInfo.queueFamilyIndexCount;
+                    drm_format_modifier.pQueueFamilyIndices = image_state->createInfo.pQueueFamilyIndices;
                     auto external_info = LvlInitStruct<VkPhysicalDeviceExternalImageFormatInfo>();
                     auto image_info = LvlInitStruct<VkPhysicalDeviceImageFormatInfo2>(&external_info);
                     image_info.format = image_state->createInfo.format;
@@ -1283,6 +1287,16 @@ bool CoreChecks::ValidateBindImageMemory(uint32_t bindInfoCount, const VkBindIma
                     // Check export operation support
                     auto check_export_support = [&](VkExternalMemoryHandleTypeFlagBits flag) {
                         external_info.handleType = flag;
+                        external_info.pNext = NULL;
+                        if (image_state->createInfo.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
+                            auto drm_modifier_properties = LvlInitStruct<VkImageDrmFormatModifierPropertiesEXT>();
+                            auto result =
+                                DispatchGetImageDrmFormatModifierPropertiesEXT(device, bind_info.image, &drm_modifier_properties);
+                            if (result == VK_SUCCESS) {
+                                external_info.pNext = &drm_format_modifier;
+                                drm_format_modifier.drmFormatModifier = drm_modifier_properties.drmFormatModifier;
+                            }
+                        }
                         auto result =
                             DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_info, &image_properties);
                         if (result != VK_SUCCESS) {
diff --git a/layers/core_checks/image_validation.cpp b/layers/core_checks/image_validation.cpp
index c56b5dabdd27..35a84c86f8ef 100644
--- a/layers/core_checks/image_validation.cpp
+++ b/layers/core_checks/image_validation.cpp
@@ -176,30 +176,35 @@ bool CoreChecks::PreCallValidateCreateImage(VkDevice device, const VkImageCreate
         }
     }
 
-    VkImageFormatProperties format_limits = {};
+    auto image_format_properties = LvlInitStruct<VkImageFormatProperties2>();
+    auto image_format_info = LvlInitStruct<VkPhysicalDeviceImageFormatInfo2>();
+    image_format_info.type = pCreateInfo->imageType;
+    image_format_info.format = pCreateInfo->format;
+    image_format_info.tiling = pCreateInfo->tiling;
+    image_format_info.usage = pCreateInfo->usage;
+    image_format_info.flags = pCreateInfo->flags;
     VkResult result = VK_SUCCESS;
     if (pCreateInfo->tiling != VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
-        result = DispatchGetPhysicalDeviceImageFormatProperties(physical_device, pCreateInfo->format, pCreateInfo->imageType,
-                                                                pCreateInfo->tiling, pCreateInfo->usage, pCreateInfo->flags,
-                                                                &format_limits);
+        if (IsExtEnabled(device_extensions.vk_khr_get_physical_device_properties2)) {
+            result = DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_format_info, &image_format_properties);
+        } else {
+            result = DispatchGetPhysicalDeviceImageFormatProperties(physical_device, pCreateInfo->format, pCreateInfo->imageType,
+                                                                    pCreateInfo->tiling, pCreateInfo->usage, pCreateInfo->flags,
+                                                                    &image_format_properties.imageFormatProperties);
+        }
     } else {
         auto modifier_list = LvlFindInChain<VkImageDrmFormatModifierListCreateInfoEXT>(pCreateInfo->pNext);
         auto explicit_modifier = LvlFindInChain<VkImageDrmFormatModifierExplicitCreateInfoEXT>(pCreateInfo->pNext);
+        auto drm_format_modifier = LvlInitStruct<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>();
+        image_format_info.pNext = &drm_format_modifier;
+        drm_format_modifier.sharingMode = pCreateInfo->sharingMode;
+        drm_format_modifier.queueFamilyIndexCount = pCreateInfo->queueFamilyIndexCount;
+        drm_format_modifier.pQueueFamilyIndices = pCreateInfo->pQueueFamilyIndices;
         if (modifier_list) {
             for (uint32_t i = 0; i < modifier_list->drmFormatModifierCount; i++) {
-                auto drm_format_modifier = LvlInitStruct<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>();
                 drm_format_modifier.drmFormatModifier = modifier_list->pDrmFormatModifiers[i];
-                auto image_format_info = LvlInitStruct<VkPhysicalDeviceImageFormatInfo2>(&drm_format_modifier);
-                image_format_info.type = pCreateInfo->imageType;
-                image_format_info.format = pCreateInfo->format;
-                image_format_info.tiling = pCreateInfo->tiling;
-                image_format_info.usage = pCreateInfo->usage;
-                image_format_info.flags = pCreateInfo->flags;
-                auto image_format_properties = LvlInitStruct<VkImageFormatProperties2>();
-
                 result =
                     DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_format_info, &image_format_properties);
-                format_limits = image_format_properties.imageFormatProperties;
 
                 /* The application gives a list of modifier and the driver
                  * selects one. If one is wrong, stop there.
@@ -207,18 +212,8 @@ bool CoreChecks::PreCallValidateCreateImage(VkDevice device, const VkImageCreate
                 if (result != VK_SUCCESS) break;
             }
         } else if (explicit_modifier) {
-            auto drm_format_modifier = LvlInitStruct<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>();
             drm_format_modifier.drmFormatModifier = explicit_modifier->drmFormatModifier;
-            auto image_format_info = LvlInitStruct<VkPhysicalDeviceImageFormatInfo2>(&drm_format_modifier);
-            image_format_info.type = pCreateInfo->imageType;
-            image_format_info.format = pCreateInfo->format;
-            image_format_info.tiling = pCreateInfo->tiling;
-            image_format_info.usage = pCreateInfo->usage;
-            image_format_info.flags = pCreateInfo->flags;
-            auto image_format_properties = LvlInitStruct<VkImageFormatProperties2>();
-
             result = DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_format_info, &image_format_properties);
-            format_limits = image_format_properties.imageFormatProperties;
         }
     }
 
@@ -238,6 +233,7 @@ bool CoreChecks::PreCallValidateCreateImage(VkDevice device, const VkImageCreate
         }
 #endif  // VK_USE_PLATFORM_ANDROID_KHR
     } else {
+        const auto format_limits = image_format_properties.imageFormatProperties;
         if (pCreateInfo->mipLevels > format_limits.maxMipLevels) {
             skip |= LogError(device, "VUID-VkImageCreateInfo-mipLevels-02255",
                              "vkCreateImage(): Image mip levels=%d exceed image format maxMipLevels=%d for format %s.",
@@ -468,8 +464,32 @@ bool CoreChecks::PreCallValidateCreateImage(VkDevice device, const VkImageCreate
 
         auto external_image_properties = LvlInitStruct<VkExternalImageFormatProperties>();
         auto image_properties = LvlInitStruct<VkImageFormatProperties2>(&external_image_properties);
-        result = DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_info, &image_properties);
-        const auto compatible_types = external_image_properties.externalMemoryProperties.compatibleHandleTypes;
+        VkExternalMemoryHandleTypeFlags compatible_types = 0;
+        if (pCreateInfo->tiling != VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
+            result = DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_info, &image_properties);
+            compatible_types = external_image_properties.externalMemoryProperties.compatibleHandleTypes;
+        } else {
+            auto modifier_list = LvlFindInChain<VkImageDrmFormatModifierListCreateInfoEXT>(pCreateInfo->pNext);
+            auto explicit_modifier = LvlFindInChain<VkImageDrmFormatModifierExplicitCreateInfoEXT>(pCreateInfo->pNext);
+            auto drm_format_modifier = LvlInitStruct<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>();
+            external_image_info.pNext = &drm_format_modifier;
+            drm_format_modifier.sharingMode = pCreateInfo->sharingMode;
+            drm_format_modifier.queueFamilyIndexCount = pCreateInfo->queueFamilyIndexCount;
+            drm_format_modifier.pQueueFamilyIndices = pCreateInfo->pQueueFamilyIndices;
+            if (modifier_list) {
+                for (uint32_t i = 0; i < modifier_list->drmFormatModifierCount; i++) {
+                    drm_format_modifier.drmFormatModifier = modifier_list->pDrmFormatModifiers[i];
+                    result = DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_info, &image_properties);
+                    compatible_types |= external_image_properties.externalMemoryProperties.compatibleHandleTypes;
+                    if (result != VK_SUCCESS)
+                        break;
+                }
+            } else if (explicit_modifier) {
+                drm_format_modifier.drmFormatModifier = explicit_modifier->drmFormatModifier;
+                result = DispatchGetPhysicalDeviceImageFormatProperties2(physical_device, &image_info, &image_properties);
+                compatible_types = external_image_properties.externalMemoryProperties.compatibleHandleTypes;
+            }
+        }
 
         if (result != VK_SUCCESS) {
             skip |= LogError(
